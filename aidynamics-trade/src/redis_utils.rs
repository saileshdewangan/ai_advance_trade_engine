#![allow(missing_docs)]

use futures::StreamExt;
use redis::AsyncCommands;
use std::sync::Arc;
// use std::sync::Arc;
use std::time::Duration;
// use serde_json::Value;
// use tokio::sync::watch::error;

// use redis::PubSub;
use tokio::sync::mpsc;
// use tokio::time::sleep;
// use tokio_tungstenite::tungstenite::protocol::Message as ws_message;

use crate::order::IndividualOrderStatus;
use crate::order::PlaceOrderReq;
use crate::trade_engine::NewTrade;
use crate::trade_engine::Strategy;
use crate::trade_engine::TradeEngine;
use crate::trade_engine::TradeEngineUpdates;
// use crate::trade_engine::TradeEngineConfig;
use crate::trade_engine::TradeRes;
use crate::trade_engine::TradeStatus;
use crate::types::TransactionType;
// use crate::websocket::angel_one_websocket::SubscriptionExchange;
// use crate::trade_handler::Trade;
// use crate::types::TransactionType;
// use crate::websocket::angel_one_websocket::SubscriptionExchange;

// use super::angel_one_websocket::SubscriptionBuilder;
use crate::websocket::angel_one_websocket::SubscriptionRequest;
// use crate::ws::SubscriptionBuilder;

// use futures_util::StreamExt as _;
// use redis::{AsyncCommands, Commands, ConnectionLike, ControlFlow, PubSubCommands};
// use tokio::time::sleep;

/// Message type enum
// pub enum WebSocketMessage {
//     /// Type of message is String
//     Text(String),
//     // Add other message types if needed
// }

#[derive(Serialize, Deserialize, Debug)]
struct TradeData {
    achieved: u32,
    comment: String,
    datetime: String,
    entry: String,
    exchange: String,
    exit: u32,
    exittime: String,
    hidden: u8,
    isdemo: u8,
    ltp: u32,
    ordertype: String,
    positiontype: String,
    producttype: String,
    qty: u32,
    scrip: String,
    segment: String,
    sl: u32,
    status: u8,
    tokenid: u32,
}

/// Data sent to
#[derive(Serialize, Deserialize, Debug)]
pub enum DataEndpoint {
    /// Data to Python
    PYTHON,
    /// Data to Node
    NODE,
    /// Data to Self
    RUST,
    /// Data to Both
    ALL,
    /// Data to WEB
    WEB,
}

/// Signal
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type", content = "data")]
pub enum Signal {
    /// Initialized app
    #[serde(rename = "initialize_app")]
    InitializeApp,

    /// Initialized a new trade engine in server when client connects
    #[serde(rename = "new_trade_engine")]
    NewTradeEngine(TradeEngine),

    /// Add Trade engine with configuration when new status of setup is updated
    #[serde(rename = "add_trade_engine")]
    AddTradeEngine {
        /// trade engine id
        trade_engine_id: u32,
        /// client id
        client_id: u32,
        /// variants data to be updated
        config: TradeEngineUpdates,
    },

    /// Add Trade engine with configuration when new status of setup is updated
    #[serde(rename = "test_stream")]
    TestStream {
        /// trade engine id
        trade_engine_id: u32,
        /// client id
        client_id: u32,
        /// Symbol name
        symbol: String,
    },

    /// Removing trade engine
    #[serde(rename = "remove_trade_engine")]
    RemoveTradeEngine(u32),

    /// update trade engine
    #[serde(rename = "update_trade_engine")]
    UpdateTradeEngine {
        /// trade_engine_id to identify TradeEngine
        trade_engine_id: u32,

        /// identify client
        client_id: u32,

        /// Config to update fields
        config: TradeEngineUpdates,
    },

    /// update trade status this is required because
    /// we are working in seperate spawn
    #[serde(rename = "update_trade_status")]
    UpdateTradeStatus {
        /// trade_engine_id to identify TradeEngine
        trade_engine_id: u32,

        /// Status of trade
        status: TradeStatus,
    },

    /// General message
    #[serde(rename = "message")]
    Message,

    /// Connection established
    #[serde(rename = "connection")]
    Connection,

    /// Connection closed
    /// When user unauthorize server this signal will be generated by node server
    #[serde(rename = "close_connection")]
    CloseConnection,

    /// Complete this close connection process
    #[serde(rename = "disconnect")]
    Disconnect(u32),

    /// Complete this close connection process
    #[serde(rename = "PING")]
    Ping,

    // /// Complete this close connection process
    // #[serde(rename = "disconnect")]
    // Disconnect { client_id: String },
    /// Live Price feed
    #[serde(rename = "pricefeed")]
    PriceFeed {
        /// token
        token: String,
        /// ltp
        ltp: f32,
    },

    /// Strategy matched
    #[serde(rename = "strategy_matched")]
    StrategyMatched,

    /// Authorization
    #[serde(rename = "auth")]
    Auth {
        /// Token to received on connection
        token: String,
    },

    /// Authorization required
    #[serde(rename = "auth_required")]
    AuthRequired(String),

    /// Authorization success
    #[serde(rename = "auth_success")]
    AuthSuccess(String),

    /// Authorization failed
    #[serde(rename = "auth_failed")]
    AuthFaild(String),

    /// Execute demo trade
    #[serde(rename = "update_execution_data")]
    UpdateExecutionData {
        /// client id
        client_id: u32,
        /// Trade engine id
        trade_engine_id: u32,
        // order: IndividualOrderStatus,
        order: IndividualOrderStatus,
        /// price
        price: f32,
        /// Margin required
        margin_required: f32,
        /// Strategy used
        strategy: Strategy,
    },

    /// Execute demo trade
    #[serde(rename = "execute_demo_trade")]
    ExecuteDemoTrade {
        /// client id
        client_id: u32,
        /// Trade engine id
        trade_engine_id: u32,
        /// Trade engine id
        order_req: PlaceOrderReq,
        /// price
        price: f32,
        /// Margin required
        margin_required: f32,
    },

    /// Order Placed all other API are called and completed
    #[serde(rename = "order_placed")]
    OrderPlaced(TradeRes),

    /// Order Rejected by broker
    #[serde(rename = "order_rejected")]
    OrderRejected(TradeRes),

    /// Order placing error
    #[serde(rename = "order_error")]
    OrderError(TradeRes),

    /// Here it will set the value of trade engine variants corresponding to trade_engine_id.
    /// When condition matched the order will be placed
    #[serde(rename = "open_new_trade")]
    OpenNewTrade(NewTrade),

    /// Updates original trade engine
    #[serde(rename = "update_active_trades")]
    UpdateActiveTrades(TradeEngine),

    /// Here intializing trades already open condition
    /// After staring the application
    #[serde(rename = "initialize_open_trade")]
    InitializeOpenTrade {
        /// Executed trades props
        new_trade: NewTrade,
        /// Trade res
        trade_res: TradeRes,
    },

    #[serde(rename = "request_square_off")]
    /// Order request from client
    RequestSquareOff {
        /// client id
        client_id: u32,
        /// Trade id to square off
        trade_id: u32,
        /// Remove trade engine on square off
        remove_trade_engine: bool,
        /// trade engine id
        trade_engine_id: u32,
    },

    #[serde(rename = "square_off_trade")]
    /// Order Placed all other API are called and completed
    SquareOffTrade {
        /// client id
        client_id: u32,
        /// order request
        order_req: PlaceOrderReq,
        /// Trade id to square off
        trade_id: u32,
        /// Trade engine id to square off
        trade_engine_id: u32,
        /// Remove trade engine on square off
        remove_trade_engine: bool,
        /// Strategy it which is applied
        strategy: Strategy,
    },

    #[serde(rename = "square_off_demo_trade")]
    /// Order Placed for square off demo trades and completed
    SquareOffDemoTrade {
        /// client id
        client_id: u32,
        /// order request
        order_req: PlaceOrderReq,
        /// Trade id to square off
        trade_id: u32,
        /// Trade engine id to square off
        trade_engine_id: u32,
        /// Remove trade engine on square off
        remove_trade_engine: bool,
        /// Strategy it which is applied
        strategy: Strategy,
        /// price
        price: f32,
    },

    /// Cancel order which is not executed
    #[serde(rename = "cancel_order")]
    CancelOrder {
        /// Symbol to cancel
        symbol: String,
        /// Matching strategy
        strategy: Strategy,
        /// Transaction type
        transaction_type: TransactionType,
        /// Trigger price
        trigger_price: f32,
    },

    #[serde(rename = "close_position")]
    /// Close position
    /// Param is trade_engine_id
    ClosePosition(u32),

    #[serde(rename = "trade_not_exist")]
    /// Trade not exist
    TradeNotExist,

    #[serde(rename = "trade_engine_exist")]
    /// Trade not exist
    TradeEngineExist {
        /// client id
        client_id: u32,
        /// status will be sent back is exist or not
        status: bool,
    },

    #[serde(rename = "trade_engine_details")]
    /// Print details of trade engine
    TradeEngineDetails {
        /// client id
        client_id: u32,
        /// stategy to match
        strategy: Strategy,
        /// symbol to search
        symbol: String,
    },

    #[serde(rename = "update_square_off")]
    /// Update square off order details
    UpdateSquareOff {
        /// client id
        client_id: u32,
        /// Trade id to square off
        trade_id: u32,
        /// Remove trade engine on square off
        remove_trade_engine: bool,
        /// Trade engine
        trade_engine_id: u32,
        /// Strategy used by this trade
        strategy: Strategy,
        /// Price
        price: f32,
        /// Order book
        order: IndividualOrderStatus,
    },

    #[serde(rename = "update_square_off_demo")]
    /// Update square off order details
    UpdateSquareOffDemo {
        /// client id
        client_id: u32,
        /// Trade id to square off
        trade_id: u32,
        /// Remove trade engine on square off
        remove_trade_engine: bool,
        /// Strategy used by this trade
        strategy: Strategy,
        /// Order book
        order: PlaceOrderReq,
        /// Price fetched
        price: f32,
    },

    #[serde(rename = "squared_off")]
    /// Acknowledgement from rust server to nodejs to square off
    SquaredOff {
        /// Trade id to square off
        trade_id: u32,
        /// Strategy
        strategy: Strategy,
        /// Trade engine id to square off
        trade_engine_id: u32,
    },

    #[serde(rename = "delete_active_trade_ids")]
    /// Delete active trade ids from active_trade_ids HashSet
    DeleteActiveTradeIds(u32),

    #[serde(rename = "add_active_trade_ids")]
    /// Delete active trade ids from active_trade_ids HashSet
    AddActiveTradeIds(u32),

    #[serde(rename = "square_off_reject")]
    /// Rejected from rust server to nodejs to square off
    SquareOffReject {
        /// Trade id to square off
        trade_id: u32,
        /// Error
        error: String,
        /// Message
        message: String,
        /// trade engine id
        trade_engine_id: u32,
    },

    #[serde(rename = "square_off_error")]
    /// Rejected from rust server to nodejs to square off
    SquareOffError {
        /// Trade id to square off
        trade_id: u32,
        /// Error
        error: String,
        /// Message
        message: String,
        /// trade engine id
        trade_engine_id: u32,
    },

    #[serde(rename = "force_square_off")]
    /// Forcefully square off trade by admin panel or server
    ForceSquareOff {
        /// Symbol to square off
        symbol: String,
        /// Matching strategy
        strategy: Strategy,
        /// Transaction type
        position_type: TransactionType,
    },
    #[serde(rename = "error")]
    /// Error thrown on web server
    Error(String),

    #[serde(rename = "subscribe")]
    /// Subscribe sender to angelone websocket
    Subscribe(SubscriptionRequest),

    #[serde(rename = "ws_connection_closed")]
    /// Internal websocket connection closed
    WsConnectionClosed,

    // ---------------------------- Signal order processor ------------------------
    #[serde(rename = "add_client")]
    /// Adds client to order processor
    AddClient {
        api_key: String,
        jwt_token: String,
        client_id: u32,
    },

    #[serde(rename = "remove_client")]
    /// Remove client to order processor
    RemoveClient { client_id: u32 },

    /// Executes order by order processor
    #[serde(rename = "execute_order")]
    ExecuteOrder {
        order_req: PlaceOrderReq,
        strategy: Strategy,
        trade_engine_id: u32,
        client_id: u32,
    },

    /// Update margin
    #[serde(rename = "update_margin")]
    UpdateMargin { client_id: u32, margin: f32 },

    /// Update margin
    #[serde(rename = "update_square_off_shared")]
    SquaredOffShared {
        client_id: u32,
        trade_engine_id: u32,
    },
}

/// NewMessage is struct to format websocket messages
#[derive(Serialize, Deserialize, Debug)]
pub struct NewMessage {
    /// Signal
    pub signal: Signal, // /// Data received from
                        // // pub from: DataEndpoint,
                        // /// Data sent to
                        // // pub to: DataEndpoint,
                        // /// Data received
                        // pub data: Value, // Use `serde_json::Value` to handle any type
}

/// Redis struct to implement redis
pub struct RedisUtils;

impl RedisUtils {
    /// Initialize and spawn the WebSocket client task
    pub async fn init(
        redis_url: String,
        mut rx: mpsc::Receiver<Signal>,
        tx: mpsc::Sender<Signal>,
        _tx_broadcast: Arc<tokio::sync::mpsc::Sender<Signal>>,
    ) {
        let tx_clone = tx.clone();
        // let tx_clone = tx_broadcast.clone();

        let client = redis::Client::open(redis_url.as_str()).expect("Invalid connection URL");

        let _redis_url_clone = redis_url.clone();

        let mut con = client.get_multiplexed_async_connection().await.unwrap();

        let _: () = redis::cmd("PING").query_async(&mut con).await.unwrap();

        con.set_response_timeout(Duration::from_secs(18000));

        println!("Connected to Redis!");
        // let _: usize = con.publish(channel, message).await.unwrap();

        let mut pubsub = client.get_async_pubsub().await.unwrap();

        // Spawn a separate task to listen for messages
        tokio::spawn(async move {
            pubsub.subscribe("rust").await.unwrap(); // Subscribing to a Redis channel
            println!("Subscribed to rust channel");
            let mut message_stream = pubsub.on_message();
            loop {
                match message_stream.next().await {
                    Some(msg) => {
                        // let payload: String = msg.get_payload().unwrap();
                        // println!("\nReceived message: {}", payload);
                        let message: String = msg.get_payload().unwrap();
                        match serde_json::from_str::<NewMessage>(&message) {
                            Ok(msg) => {
                                tx_clone.send(msg.signal).await.unwrap();
                            }
                            Err(e) => {
                                eprintln!("Failed to deserialize message: {}", e);
                            }
                        }
                    }
                    None => {
                        println!("No message received....");
                    }
                }
            }
        });

        tokio::spawn(async move {
            while let Some(message) = rx.recv().await {
                let msg_to_send = serde_json::to_string(&message)
                    .expect("JSON serialize failed : Sending Redis Message");
                let mut con = client.get_multiplexed_async_connection().await.unwrap();
                let _: () = con.publish("broadcast", msg_to_send).await.unwrap();
                // let _result: String = client
                //     .xadd("aid_stream", "*", &[("data", msg_to_send)])
                //     .unwrap();
                // println!("Message added to Redis stream with ID: {}", result);
            }
        });
    }
}
