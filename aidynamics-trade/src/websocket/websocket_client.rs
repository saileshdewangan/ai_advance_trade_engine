use futures::{SinkExt, StreamExt};
// use serde_json::Value;
// use tokio::sync::watch::error;

use std::sync::Arc;
use tokio::sync::mpsc;
use tokio::sync::Mutex;
use tokio::time::{sleep, Duration};
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::protocol::Message as ws_message;

use crate::order::PlaceOrderReq;
use crate::trade_engine::TradeEngine;
use crate::trade_engine::TradeEngineUpdates;
// use crate::trade_engine::TradeEngineConfig;
use crate::trade_engine::TradeRes;
use crate::websocket::angel_one_websocket::SubscriptionExchange;
// use crate::trade_handler::Trade;
// use crate::types::TransactionType;
// use crate::websocket::angel_one_websocket::SubscriptionExchange;

// use super::angel_one_websocket::SubscriptionBuilder;
use super::angel_one_websocket::SubscriptionRequest;
// use crate::ws::SubscriptionBuilder;

/// Message type enum
pub enum WebSocketMessage {
    /// Type of message is String
    Text(String),
    // Add other message types if needed
}

#[derive(Serialize, Deserialize, Debug)]
struct TradeData {
    achieved: u32,
    comment: String,
    datetime: String,
    entry: String,
    exchange: String,
    exit: u32,
    exittime: String,
    hidden: u8,
    isdemo: u8,
    ltp: u32,
    ordertype: String,
    positiontype: String,
    producttype: String,
    qty: u32,
    scrip: String,
    segment: String,
    sl: u32,
    status: u8,
    tokenid: u32,
}

/// Data sent to
#[derive(Serialize, Deserialize, Debug)]
pub enum DataEndpoint {
    /// Data to Python
    PYTHON,
    /// Data to Node
    NODE,
    /// Data to Self
    RUST,
    /// Data to Both
    ALL,
    /// Data to WEB
    WEB,
}

/// Signal
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", content = "data")]
pub enum Signal {
    /// Initialized a new trade engine in server when client connects
    #[serde(rename = "new_trade_engine")]
    NewTradeEngine(TradeEngine),

    /// Add Trade engine with configuration when new status of setup is updated
    #[serde(rename = "add_trade_engine")]
    AddTradeEngine {
        /// trade engine id
        trade_engine_id: u32,
        /// client id
        client_id: u32,
        /// variants data to be updated
        config: TradeEngineUpdates,
    },

    /// Removing trade engine
    #[serde(rename = "remove_trade_engine")]
    RemoveTradeEngine(u32),

    /// update trade engine
    #[serde(rename = "update_trade_engine")]
    UpdateTradeEngine {
        /// trade_engine_id to identify TradeEngine
        trade_engine_id: u32,

        /// identify client
        client_id: u32,

        /// Config to update fields
        config: TradeEngineUpdates,
    },
    /// General message
    #[serde(rename = "message")]
    Message,

    /// Connection established
    #[serde(rename = "connection")]
    Connection,

    /// Connection closed
    /// When user unauthorize server this signal will be generated by node server
    #[serde(rename = "close_connection")]
    CloseConnection,

    /// Complete this close connection process
    #[serde(rename = "disconnect")]
    Disconnect(u32),

    // /// Complete this close connection process
    // #[serde(rename = "disconnect")]
    // Disconnect { client_id: String },
    /// Live Price feed
    #[serde(rename = "pricefeed")]
    PriceFeed {
        /// token
        token: String,
        /// ltp
        ltp: f32,
        /// is index
        is_index: bool,
    },

    /// Strategy matched
    #[serde(rename = "strategy_matched")]
    StrategyMatched,

    /// Authorization
    #[serde(rename = "auth")]
    Auth {
        /// Token to received on connection
        token: String,
    },

    /// Authorization required
    #[serde(rename = "auth_required")]
    AuthRequired(String),

    /// Authorization success
    #[serde(rename = "auth_success")]
    AuthSuccess(String),

    /// Authorization failed
    #[serde(rename = "auth_failed")]
    AuthFaild(String),

    /// Execute trade
    #[serde(rename = "execute_trade")]
    ExecuteTrade(PlaceOrderReq),

    /// Order Placed all other API are called and completed
    #[serde(rename = "order_placed")]
    OrderPlaced(TradeRes),

    /// Here it will set the value of trade engine variants corresponding to trade_engine_id.
    /// When condition matched the order will be placed
    #[serde(rename = "new_trade")]
    NewTrade(TradeEngine),

    // /// Order Placed all other API are called and completed
    // #[serde(rename = "square_off_trade")]
    // SquareOffTrade(PlaceOrderReq),
    #[serde(rename = "square_off_trade")]
    /// Order Placed all other API are called and completed
    SquareOffTrade {
        /// client id
        client_id: u32,
        /// order request
        order_req: PlaceOrderReq,
        /// Trade id to square off
        trade_id: u32,
    },
    #[serde(rename = "trade_not_exist")]
    /// Trade not exist
    TradeNotExist,

    #[serde(rename = "trade_engine_exist")]
    /// Trade not exist
    TradeEngineExist {
        /// client id
        client_id: u32,
        /// status will be sent back is exist or not
        status: bool,
    },

    #[serde(rename = "square_off_trade_req")]
    /// This request will be sent by client
    /// when REST api is called, to square off trade
    SquareOffTradeReq {
        /// client id
        client_id: u32,
        /// Trade id to square off
        trade_id: u32,
    },

    // #[serde(rename = "square_off_confirmed")]
    // /// Confirmation from rust server to nodejs to square off
    // SquareOffConfirmed {
    //     /// Trade id to square off
    //     trade_id: u32,
    //     /// Order req to place
    //     order_req: PlaceOrderReq,
    // },

    #[serde(rename = "square_off_acknowledge")]
    /// Acknowledgement from rust server to nodejs to square off
    SquaredOff {
        /// Trade id to square off
        trade_id: u32,
        /// Order req to place
        order_req: PlaceOrderReq,
        /// Client id
        client_id:u32
    },

    #[serde(rename = "square_off_reject")]
    /// Rejected from rust server to nodejs to square off
    SquareOffReject {
        /// Trade id to square off
        trade_id: u32,
        /// Error
        error: String,
        /// Message
        message: String,
    },

    #[serde(rename = "error")]
    /// Error thrown on web server
    Error(String),

    #[serde(rename = "subscribe")]
    /// Subscribe sender to angelone websocket
    Subscribe(SubscriptionRequest),

    #[serde(rename = "ws_connection_closed")]
    /// Internal websocket connection closed
    WsConnectionClosed,
}

/// NewMessage is struct to format websocket messages
#[derive(Serialize, Deserialize, Debug)]
pub struct NewMessage {
    /// Signal
    pub signal: Signal, // /// Data received from
                        // // pub from: DataEndpoint,
                        // /// Data sent to
                        // // pub to: DataEndpoint,
                        // /// Data received
                        // pub data: Value, // Use `serde_json::Value` to handle any type
}

/// Websocket client for server connectivity
pub struct WebSocketClient;

impl WebSocketClient {
    /// Initialize and spawn the WebSocket client task
    pub async fn connect(
        ws_url: String,
        mut rx: mpsc::Receiver<Signal>,
        tx: mpsc::Sender<Signal>,
        auth_token: String,
    ) {
        let tx_clone = tx.clone();
        let tx_check_ws = tx.clone();

        // Spawn the WebSocket client task
        tokio::task::spawn(async move {
            // Connect to the WebSocket server
            let (ws_stream, _) = connect_async(ws_url).await.expect("Failed to connect");

            println!("WebSocket connection established");

            // Split the WebSocket stream into a sender (sink) and receiver (stream)
            let (write, mut read) = ws_stream.split();

            println!("AUTH TOKEN IS = {:?}", auth_token);

            let auth_message = NewMessage {
                signal: Signal::Auth { token: auth_token },
            };

            // Serialize the message and send it
            let serialized_message = serde_json::to_string(&auth_message.signal).unwrap();
            let write = Arc::new(Mutex::new(write));
            {
                let mut write_locked = write.lock().await;
                if let Err(e) = write_locked
                    .send(ws_message::Text(serialized_message))
                    .await
                {
                    println!("Error sending Auth message: {:?}", e);
                }
            }

            // Task to handle incoming WebSocket messages
            let read_task = tokio::spawn({
                let _write_clone = write.clone(); // Clone `write` for later use

                async move {
                    while let Some(msg) = read.next().await {
                        match msg {
                            Ok(message) => {
                                match message {
                                    ws_message::Text(text) => {
                                        println!("\nWS MESSAGE RECEIVED : {:?}", text);
                                        match serde_json::from_str::<NewMessage>(&text) {
                                            Ok(msg) => {
                                                // Handle each signal
                                                match msg.signal {
                                                    Signal::Auth { token } => {
                                                        println!("Auth data : {:?}", token);
                                                    }
                                                    Signal::AuthSuccess(data) => {
                                                        println!("{:?}", data);
                                                    }
                                                    Signal::AuthFaild(data) => {
                                                        println!("{:?}", data);
                                                    }
                                                    Signal::NewTradeEngine(trade_engine) => {
                                                        println!(
                                                            "\n\n Engine  {:?} : ",
                                                            trade_engine
                                                        );

                                                        tx_clone
                                                            .send(Signal::NewTradeEngine(
                                                                trade_engine,
                                                            ))
                                                            .await
                                                            .unwrap();
                                                    }
                                                    Signal::AddTradeEngine {
                                                        trade_engine_id,
                                                        client_id,
                                                        config,
                                                    } => {
                                                        println!(
                                                            "\n\n Engine  {:?} : ",
                                                            trade_engine_id
                                                        );

                                                        let mut trade_engine =
                                                            TradeEngine::default();
                                                        trade_engine.client_id = client_id;
                                                        trade_engine.strategy = config.strategy;
                                                        trade_engine.symbol = config.symbol;
                                                        trade_engine.max_price = config.max_price;
                                                        trade_engine.max_trades = config.max_trades;
                                                        trade_engine.max_loss = config.max_loss;
                                                        trade_engine.sl = config.sl;
                                                        trade_engine.trailing_sl =
                                                            config.trailing_sl;
                                                        trade_engine.quantity = config.quantity;
                                                        trade_engine.target = config.target;
                                                        trade_engine.transaction_type =
                                                            config.transaction_type;
                                                        trade_engine.segment =
                                                            SubscriptionExchange::NSEFO;

                                                        tx_clone
                                                            .send(Signal::NewTradeEngine(
                                                                trade_engine,
                                                            ))
                                                            .await
                                                            .unwrap();
                                                    }
                                                    Signal::UpdateTradeEngine {
                                                        trade_engine_id,
                                                        client_id,
                                                        config,
                                                    } => {
                                                        println!(
                                                            "\n\n Engine Update  {:?} : ",
                                                            config
                                                        );
                                                        tx_clone
                                                            .send(Signal::UpdateTradeEngine {
                                                                trade_engine_id,
                                                                client_id,
                                                                config,
                                                            })
                                                            .await
                                                            .unwrap();
                                                    }
                                                    Signal::RemoveTradeEngine(trade_engine_id) => {
                                                        tx_clone
                                                            .send(Signal::RemoveTradeEngine(
                                                                trade_engine_id,
                                                            ))
                                                            .await
                                                            .unwrap();
                                                    }
                                                    Signal::TradeEngineExist {
                                                        client_id,
                                                        status,
                                                    } => {
                                                        tx_clone
                                                            .send(Signal::TradeEngineExist {
                                                                client_id,
                                                                status,
                                                            })
                                                            .await
                                                            .unwrap();
                                                    }
                                                    Signal::Disconnect(data) =>
                                                    // Retrieve the trade_engine_id from msg.data
                                                    {
                                                        let client_id = data;
                                                        println!(
                                                            "Closing connection for client_id: {}",
                                                            client_id
                                                        );

                                                        // Send the signal with trade_engine_id to stop the trade engine
                                                        if let Err(e) = tx_clone
                                                            .send(Signal::Disconnect(
                                                                client_id,
                                                            ))
                                                            .await
                                                        {
                                                            eprintln!("Failed to send Disconnect signal: {:?}", e);
                                                        }
                                                    }
                                                    Signal::SquareOffTradeReq {
                                                        client_id,
                                                        trade_id,
                                                    } => {
                                                        // Send the signal with clientid and tradeid to square off trade req
                                                        if let Err(e) = tx_clone
                                                            .send(Signal::SquareOffTradeReq {
                                                                client_id,
                                                                trade_id,
                                                            })
                                                            .await
                                                        {
                                                            eprintln!("Failed to send SquareOffConfirm signal: {:?}", e);
                                                        }
                                                    }

                                                    // serde_json::from_value(msg.data)
                                                    //     .unwrap();
                                                    Signal::StrategyMatched => {
                                                        println!("Strategy matched.");
                                                    }
                                                    _ => {
                                                        println!("Other signal received....");
                                                    }
                                                }
                                            }
                                            Err(e) => {
                                                eprintln!("Failed to deserialize message: {}", e);
                                            }
                                        }
                                    }
                                    ws_message::Pong(payload) => {
                                        println!("Pong Payload = {:?}", payload);
                                    }
                                    _ => {
                                        println!("Other message type received");
                                    }
                                }
                            }
                            Err(e) => {
                                eprintln!("Error receiving message: {}", e);
                            }
                        }
                    }
                }
            });

            // Task to listen for messages from the main thread and send them to the WebSocket
            let write_clone = write.clone();
            tokio::spawn(async move {
                while let Some(message) = rx.recv().await {
                    let mut write_locked = write_clone.lock().await;
                    let msg_to_send = ws_message::Text(serde_json::to_string(&message).unwrap());
                    if let Err(e) = write_locked.send(msg_to_send).await {
                        eprintln!("Failed to send message: {}", e);
                    }
                }
            });

            // Task to send ping messages periodically every 30 seconds
            tokio::spawn({
                let write_clone = write.clone();

                async move {
                    loop {
                        sleep(Duration::from_secs(30)).await;
                        let mut write_locked = write_clone.lock().await;
                        if let Err(e) = write_locked.send(ws_message::Ping(vec![])).await {
                            eprintln!("Error sending ping: {:?}", e);
                            tx_check_ws.send(Signal::WsConnectionClosed).await.unwrap();
                            break;
                        }
                        println!("Sent ping");
                    }
                }
            });

            // Wait for the read task to finish
            if let Err(e) = read_task.await {
                eprintln!("\n\nRead task failed: {}", e);
            }

            println!("\n\nWebSocket connection closed.");
        });
    }
}
